[{"title":"并查集板子题","url":"/2021/02/01/bing-cha-ji/","content":"HDU 1213 How Many Tables题目链接\n题目大意给定n个人，和m条关系，需要把有关系的人分配到同一个桌子上，而没有关系的人不喜欢坐在同一个桌子上，需要知道准备几个桌子\n思路一道并查集板子入门题，只需要统计s[i] == i的个数即可知道需要分配几个桌子\n源码#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define ll long longusing namespace std;const int INF = 0x3f3f3f3f;const int maxn = 1005;int s[maxn],height[maxn];void init_set()&#123; // 初始化并查集    for(int i=1;i&lt;=maxn;++i)&#123;        s[i] = i;        height[i] = 0;    &#125;&#125;int find_set(int x)&#123; // 路径压缩的查询    if(x != s[x]) s[x] = find_set(s[x]);    return s[x];&#125;void union_set(int x,int y)&#123; // 根据树高度进行合并    x = find_set(x); y = find_set(y);    if(height[x] == height[y])&#123;        height[x] += 1;        s[y] = x;    &#125;    else if(height[x]&gt;height[y])        s[y] = x;    else        s[x] = y;&#125;int main()&#123;    int T; cin &gt;&gt; T;    while(T--)&#123;        int ans = 0;        init_set();        int n,m; cin &gt;&gt; n &gt;&gt; m;        for(int i=1;i&lt;=m;++i)&#123;            int x[2];            cin &gt;&gt; x[0] &gt;&gt; x[1];            union_set(x[0],x[1]);        &#125;        for(int i=1;i&lt;=n;++i)&#123;            if(s[i] == i)                 ans++;        &#125;        cout &lt;&lt; ans &lt;&lt; endl;    &#125;    return 0;&#125;\nHDU 1272 小希的迷宫题目链接\n题目大意给定一些边组成一个无向图，要求任意两个点有且仅有一条路径可以相通\n思路使用并查集来将这些边加入进去，如果在加入时发现这个点已经加入过了，即s[x] =  s[y]就认为这个迷宫是不合法的，这个题要注意要求是“有且仅有一条”，如果最后出现了两个集合同样也不满足这一个要求，数据有些坑，如果只输入0 0也要输出Yes\n源码#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define ll long longusing namespace std;const int INF = 0x3f3f3f3f;const int maxn = 100005;int s[maxn],height[maxn],Flag[maxn];void init_set()&#123;    for(int i=1;i&lt;=maxn;++i)&#123;        s[i] = i;        height[i] = 0;        Flag[i] = 0;    &#125;&#125;int find_set(int x)&#123;    if(x != s[x]) s[x] = find_set(s[x]);    return s[x];&#125;void union_set(int x,int y)&#123;    x = find_set(x); y = find_set(y);    if(height[x] == height[y])&#123;        height[x] += 1;        s[y] = x;    &#125;    else if(height[x]&gt;height[y])        s[y] = x;    else        s[x] = y;&#125;int main()&#123;    int a,b;    while(~scanf(&quot;%d%d&quot;,&amp;a,&amp;b))&#123;        if(a == -1 || b == -1) break;        init_set();        int flag = 0;        while(1)&#123;            if(a == 0 || b == 0) break;            if(find_set(a) == find_set(b))&#123; // 如果相等意味着这条边已经存在了，不满足“只有一条”                flag = 1; // 不能直接break，还有数据没读进来            &#125;            union_set(a,b);            Flag[a] =Flag[b] = 1; // 表示这个数出现过，因为数据并不保证1~N都会出现            scanf(&quot;%d%d&quot;,&amp;a,&amp;b);        &#125;        if(flag == 1)cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;        else&#123;            flag = 0;            for(int i=0;i&lt;=maxn;++i)                if(Flag[i]&amp;&amp;s[i] == i) flag++; // 只能有一个点同时满足出现过，并且还是一个独立的集合的条件            if(flag &gt; 1)cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;            else cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;        &#125;    &#125;    return 0;&#125;\nPOJ 1611 The Suspects题目链接\n题目大意共有0~n-1个学生，分成了m个组，一个同学可以加入不同的组，规定0号为感染者，与感染者是密接的人有多少\n思路只需要把这些组加入到并查集之中，然后查找有多少个人和0号是同一组的\n#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define ll long longusing namespace std;const int INF = 0x3f3f3f3f;const int maxn = 30005;int s[maxn],height[maxn];void init_set(int tot)&#123; // 初始化并查集    for(int i=0;i&lt;=tot;++i)&#123;        s[i] = i;        height[i] = 0;    &#125;&#125;int find_set(int x)&#123; // 路径压缩的查询    if(x != s[x]) s[x] = find_set(s[x]);    return s[x];&#125;void union_set(int x,int y)&#123; // 根据树高度进行合并    x = find_set(x); y = find_set(y);    if(height[x] == height[y])&#123;        height[x] += 1;        s[y] = x;    &#125;    else if(height[x]&gt;height[y])        s[y] = x;    else        s[x] = y;&#125;int main()&#123;    while(1)&#123;        int n,m;        cin &gt;&gt; n &gt;&gt; m;        if(n == 0 &amp;&amp; m == 0) break;        init_set(n);        while(m--)&#123;            int num;            cin &gt;&gt; num;            int pre_peo;            for(int i=1;i&lt;=num;++i)&#123;                int now_peo;                cin &gt;&gt; now_peo;                if(i == 1) // 第一个人没有前置，所以就安排他自己                    pre_peo = now_peo;                union_set(pre_peo,now_peo);                pre_peo = now_peo;            &#125;        &#125;        int res = 1; // 0自己也算在其中，所以从1开始计数        int suspect = find_set(0);        for(int i=1;i&lt;n;++i)&#123;            if(find_set(i) == suspect)res++;         &#125;        cout &lt;&lt; res &lt;&lt; endl;    &#125;    return 0;&#125;\nPOJ 2246 Wireless Network题目链接\n题目大意地震后计算机通讯受损，有两个操作，一个可以维修一个计算机，一个检查两个计算机能否通讯，两个计算机距离小于等于d即认为可以通讯，或着计算机AC以及AB可以通讯，则认为BC也可以通讯\n思路每一次修复完一个计算机，即在所有维修过的计算机中查询能否通讯，如果可以就把这两个计算机加入到同一个集合之中，检查时只需要查询两个计算机是否在一个集合之中即可\n源码#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#define ll long longusing namespace std;const double eps = 1e-5;const int INF = 0x3f3f3f3f;const int maxn = 1005;int n,d,cnt;int s[maxn],height[maxn],flag[maxn],vis[maxn];struct point&#123;    int x,y;&#125;a[maxn];void init_set(int tot)&#123; // 初始化并查集    for(int i=0;i&lt;=tot;++i)&#123;        s[i] = i;        height[i] = 0;        flag[i] = 0;    &#125;&#125;int find_set(int x)&#123; // 路径压缩的查询    if(x != s[x]) s[x] = find_set(s[x]);    return s[x];&#125;void union_set(int x,int y)&#123; // 根据树高度进行合并    x = find_set(x); y = find_set(y);    if(height[x] == height[y])&#123;        height[x] += 1;        s[y] = x;    &#125;    else if(height[x]&gt;height[y])        s[y] = x;    else        s[x] = y;&#125;void connect(int x)&#123;    for(int i=0;i&lt;cnt;++i)&#123;        double dis = sqrt((double)(pow((a[x].x-a[vis[i]].x),2)+pow((a[x].y-a[vis[i]].y),2)));        if(dis-d&lt;=eps)            union_set(x,vis[i]);    &#125;&#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; d;    init_set(maxn);    for(int i=1;i&lt;=n;++i)        cin &gt;&gt; a[i].x &gt;&gt; a[i].y;    char ope;    while(~scanf(&quot;%c&quot;,&amp;ope))&#123;        if(ope == &#x27;O&#x27;)&#123;            int now;            cin &gt;&gt; now;            connect(now);            flag[now] = 1;            vis[cnt++] = now;        &#125;        if(ope == &#x27;S&#x27;)&#123;            int test_a,test_b;            cin &gt;&gt; test_a &gt;&gt; test_b;            if(flag[test_b]&amp;&amp;flag[test_a]&amp;&amp;find_set(test_a) == find_set(test_b))                cout &lt;&lt; &quot;SUCCESS&quot; &lt;&lt; endl;            else                cout &lt;&lt; &quot;FAIL&quot; &lt;&lt; endl;        &#125;    &#125;    return 0;&#125;\n","tags":["xcpc"]},{"title":"PageRank学习笔记","url":"/2020/11/01/la-assignment/","content":"\n  出于线性代数Assignment的需要，学习了网页搜索领域很有名的PageRank算法，决定在这里记录下一些笔记\n\n简介PageRank简称PR，Google创始人拉里佩奇在提出此算法后创建了Google搜索引擎，其可以为网页打分以决定网页的排序，虽然搜索引擎对于网页的排序还由其他一些因素影响（比如某度根据就给的💸有关），但PageRank算法提供了一个很重要的判断标准。\n\n  也有人说PageRank算法是由创始人拉里佩奇（Larry Page）的名字命名的\n\nPageRank的核心原理基于一个重要的假设：一个重要的网站往往会被很多的网站所引用（指向）\n基于这个假设，如果一个网站被很多网站指向，或者是被本身“权值”比较高的网站所指向，那么这个网站也是一个较为重要的网站\n一个小的例子核心的思想不太难，我们直接从一个小的例子说起。\n现在有四个网站，A B C D，我们将四个网站抽象为图中的的四个节点（Node），并且将一个网站指向另一个网站的链接抽象为一条边（Edge），于是一个图诞生了\n（直接用的作业里面画的图，字母和数字一一对应）\n\n每个网站有一个最初的PageRank值，在最初的算法中，这个值是1，但为了满足概率介于1和0之间，所以我们将他们的值都设置为，在这个例子中，这个值是0.25\n对于一个网站的PR值，我们称为\n对于A节点，C节点和D节点指向了它，所以我们可以得到下面的式子：\n\n但是，D不仅指向了A，还指向了C，所以，D给A投的票相当于，因此，刚才的式子应该是：\n\n如果我们对于将页面向外指向的链接总数为\n那么，对于点A，就有：\n\n同理可得别的点的PR值，并且通过不断的递归，这个值将趋于稳定\n同样可以采用矩阵的方式计算：\n\n第n列表示，节点N向外指向的点\n比如，第1列，第2 3 4行 为 ，表示A指向3个节点，分别是节点BCD\n\n我们不断计算\n就可以得到一个稳定的矩阵，这就是这四个网站的PageRank值\n一个问题为了方便理解，我们把“随机浏览者”的概念简化。\n我们在日常生活上网时，不只是从一个网站点到另一个网站，还有可能是通过上方的地址栏直接输入url，跳转到对应的网址，所以我们在计算PageRank值时，引入一个阻尼系数d（damping factor），根据统计，这个直接输入网址的概率大概四0.85，其意义是：任意时刻，用户访问到某页面后继续访问下一个页面的概率，相对应的1-d则是用户停止点击，随机浏览新网页的概率\n于是我们就得到了最终的求一个页面PageRank值的公式：\n\n实例下面是我爬取学校网站，得到数据后，对其进行的排序的一个例子\nWe noticed that the links related to BJUT were not been indexed by Baidu or Google, So we apply the PageRank algorithm to BJUT’s web pages. We use MATLAB R2020b to implement this algorithm and all data is obtained using python crawler.\nCreate a directed graph with the sparse adjacency matrix G, using the urls contained in name as node names.\nG = digraph(s,t,[],name)\nG =   digraph - with properties:    Edges: [209×1 table]    Nodes: [55×1 table]\nWe set the damping factor 0.85, and use 200 iterations to compute the PageRank of sparse adjacency matrix G.  And add the scores and degree information into the nodes tables. \npr = centrality(G,'pagerank','MaxIterations',200,'FollowProbability',0.85);G.Nodes.PageRank = pr;G.Nodes.InDegree = indegree(G);G.Nodes.OutDegree = outdegree(G);\nPrint the top 25 scores.\nG.Nodes(1:25,:)ans = 25×4 table\n\n\n\n\nName\nPageRank\nInDegree\nOutDegree\n\n\n\n1\n‘http://www.bjut.edu.cn/'\n0.0552\n20\n13\n\n\n2\n‘http://news.bjut.edu.cn/'\n0.0185\n7\n4\n\n\n3\n‘https://app.bjut.edu.cn/'\n0.0110\n2\n2\n\n\n4\n‘http://60.bjut.edu.cn/'\n0.0455\n3\n1\n\n\n5\n‘http://portal2nd.bjut.edu.cn/'\n0.0067\n4\n40\n\n\n6\n‘http://eol2018.bjut.edu.cn/'\n0.0110\n2\n2\n\n\n7\n‘http://lib.bjut.edu.cn/'\n0.0191\n6\n2\n\n\n8\n‘http://iptv.bjut.edu.cn/'\n0.0422\n2\n1\n\n\n9\n‘http://gdjwgl.bjut.edu.cn/'\n0.0505\n3\n1\n\n\n10\n‘http://xgxt.bjut.edu.cn/'\n0.0422\n2\n1\n\n\n11\n‘https://cwc.bjut.edu.cn/'\n0.0112\n3\n2\n\n\n12\n‘http://bjutcie.bjut.edu.cn'\n0.0089\n2\n3\n\n\n13\n‘http://facte.bjut.edu.cn/'\n0.0081\n2\n4\n\n\n14\n‘http://my.bjut.edu.cn/'\n0.0929\n4\n1\n\n\nExtract and draw a subgraph that contains all nodes with a score greater than 0.005. Color the graph nodes according to their PageRank score.\nH = subgraph(G,find(G.Nodes.PageRank &gt; 0.005));plot(H,'NodeLabel',{},'NodeCData',H.Nodes.PageRank,'Layout','force');title('Websites linked to https://www.bjut.edu.cn')colorbar\n\n","tags":["algorithm"]},{"title":"带权并查集（HDU3038）","url":"/2021/02/02/dai-quan-bcj/","content":"第一次接触带权并查集，给出我看过的很厉害的博客\n并查集到带权并查集-zhxmdefj【蒟蒻图论】并查集及其升级算法\n看懂了大概意思\nHDU 3038 How Many Answers Are Wrong 题目链接\n题目大意给出一个区间[1,n]，m次操作，给出[L,R]的和为sum，如果这组操作与前面的矛盾则认为冲突，问有多少冲突数\n思路分为两种情况，如果两个端点的s[]相同，就说明已经可以判断这个区间是不是合法了，如果不相同，说明这个区间还没有数据，那么就应该把这个区间加进去，也就是把这两个端点带权加入到并查集之中。\n这个题有两点需要注意，一是多组数据，二是[5,5]代表的是只有五号点，而我们需要的是一个左开右闭的区间（L&lt;x&lt;=R），因此需要让L减一\n源码#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int maxn = 200005;int n,m;int s[maxn],value[maxn];void init()&#123;    for(int i=0;i&lt;maxn;++i)&#123;        s[i] = i;        value[i] = 0;    &#125;&#125;int find_set(int x)&#123;    if(s[x] == x)&#123;        return x;    &#125;    else&#123;        int pre = s[x];        s[x] = find_set(s[x]);        value[x] = value[x] + value[pre];        return s[x];    &#125;&#125;void merge_set(int x,int y,int z)&#123;    int xRoot = find_set(x);    int yRoot = find_set(y);    s[xRoot] = yRoot;    value[xRoot] = value[y] + z - value[x];&#125;int main()&#123;    while(cin &gt;&gt; n &gt;&gt; m) &#123;        init();        int res = 0;        while(m--) &#123;            int x, y, z;            cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;            x--;            if (find_set(x) == find_set(y)) &#123;                if (value[x] - value[y] != z)                    res++;            &#125;            else &#123;                merge_set(x, y, z);            &#125;        &#125;        cout &lt;&lt; res &lt;&lt; endl;    &#125;&#125;\n","tags":["xcpc"]}]