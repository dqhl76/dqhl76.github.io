<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>dqhl&#39;s blog</title>
  
  <subtitle>Just a student!</subtitle>
  <link href="https://dqhl76.com/atom.xml" rel="self"/>
  
  <link href="https://dqhl76.com/"/>
  <updated>2021-02-01T07:18:58.354Z</updated>
  <id>https://dqhl76.com/</id>
  
  <author>
    <name>dqhl76</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>并查集板子题和kuangbin的专题五</title>
    <link href="https://dqhl76.com/2021/02/01/bing-cha-ji/"/>
    <id>https://dqhl76.com/2021/02/01/bing-cha-ji/</id>
    <published>2021-02-01T02:11:56.000Z</published>
    <updated>2021-02-01T07:18:58.354Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HDU-1213-How-Many-Tables"><a href="#HDU-1213-How-Many-Tables" class="headerlink" title="HDU 1213 How Many Tables"></a>HDU 1213 How Many Tables</h3><p><a class="link"   href="https://vjudge.net/problem/HDU-1213" >题目链接<i class="fas fa-external-link-alt"></i></a></p><h4 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h4><p>给定n个人，和m条关系，需要把有关系的人分配到同一个桌子上，而没有关系的人不喜欢坐在同一个桌子上，需要知道准备几个桌子</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>一道并查集板子入门题，只需要统计<code>s[i] == i</code>的个数即可知道需要分配几个桌子</p><h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1005</span>;</span><br><span class="line"><span class="keyword">int</span> s[maxn],height[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_set</span><span class="params">()</span></span>&#123; <span class="comment">// 初始化并查集</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=maxn;++i)&#123;</span><br><span class="line">        s[i] = i;</span><br><span class="line">        height[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_set</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="comment">// 路径压缩的查询</span></span><br><span class="line">    <span class="keyword">if</span>(x != s[x]) s[x] = find_set(s[x]);</span><br><span class="line">    <span class="keyword">return</span> s[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">union_set</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123; <span class="comment">// 根据树高度进行合并</span></span><br><span class="line">    x = find_set(x); y = find_set(y);</span><br><span class="line">    <span class="keyword">if</span>(height[x] == height[y])&#123;</span><br><span class="line">        height[x] += <span class="number">1</span>;</span><br><span class="line">        s[y] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(height[x]&gt;height[y])</span><br><span class="line">        s[y] = x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        s[x] = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T; <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        init_set();</span><br><span class="line">        <span class="keyword">int</span> n,m; <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> x[<span class="number">2</span>];</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x[<span class="number">0</span>] &gt;&gt; x[<span class="number">1</span>];</span><br><span class="line">            union_set(x[<span class="number">0</span>],x[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == i) </span><br><span class="line">                ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="HDU-1272-小希的迷宫"><a href="#HDU-1272-小希的迷宫" class="headerlink" title="HDU 1272 小希的迷宫"></a>HDU 1272 小希的迷宫</h3><p><a class="link"   href="https://vjudge.net/problem/HDU-1272" >题目链接<i class="fas fa-external-link-alt"></i></a></p><h4 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h4><p>给定一些边组成一个无向图，要求任意两个点有且仅有一条路径可以相通</p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>使用并查集来将这些边加入进去，如果在加入时发现这个点已经加入过了，即<code>s[x] =  s[y]</code>就认为这个迷宫是不合法的，这个题要注意要求是<strong>“有且仅有一条”</strong>，如果最后出现了两个集合同样也不满足这一个要求，数据有些坑，如果只输入<code>0 0</code>也要输出<code>Yes</code></p><h4 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> s[maxn],height[maxn],Flag[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_set</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=maxn;++i)&#123;</span><br><span class="line">        s[i] = i;</span><br><span class="line">        height[i] = <span class="number">0</span>;</span><br><span class="line">        Flag[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_set</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x != s[x]) s[x] = find_set(s[x]);</span><br><span class="line">    <span class="keyword">return</span> s[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">union_set</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    x = find_set(x); y = find_set(y);</span><br><span class="line">    <span class="keyword">if</span>(height[x] == height[y])&#123;</span><br><span class="line">        height[x] += <span class="number">1</span>;</span><br><span class="line">        s[y] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(height[x]&gt;height[y])</span><br><span class="line">        s[y] = x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        s[x] = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b))&#123;</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="number">-1</span> || b == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        init_set();</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a == <span class="number">0</span> || b == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(find_set(a) == find_set(b))&#123; <span class="comment">// 如果相等意味着这条边已经存在了，不满足“只有一条”</span></span><br><span class="line">                flag = <span class="number">1</span>; <span class="comment">// 不能直接break，还有数据没读进来</span></span><br><span class="line">            &#125;</span><br><span class="line">            union_set(a,b);</span><br><span class="line">            Flag[a] =Flag[b] = <span class="number">1</span>; <span class="comment">// 表示这个数出现过，因为数据并不保证1~N都会出现</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">1</span>)<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=maxn;++i)</span><br><span class="line">                <span class="keyword">if</span>(Flag[i]&amp;&amp;s[i] == i) flag++; <span class="comment">// 只能有一个点同时满足出现过，并且还是一个独立的集合的条件</span></span><br><span class="line">            <span class="keyword">if</span>(flag &gt; <span class="number">1</span>)<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;HDU-1213-How-Many-Tables&quot;&gt;&lt;a href=&quot;#HDU-1213-How-Many-Tables&quot; class=&quot;headerlink&quot; title=&quot;HDU 1213 How Many Tables&quot;&gt;&lt;/a&gt;HDU 1213 How M</summary>
      
    
    
    
    
    <category term="xcpc" scheme="https://dqhl76.com/tags/xcpc/"/>
    
  </entry>
  
  <entry>
    <title>PageRank学习笔记</title>
    <link href="https://dqhl76.com/2020/11/01/la-assignment/"/>
    <id>https://dqhl76.com/2020/11/01/la-assignment/</id>
    <published>2020-11-01T02:00:00.000Z</published>
    <updated>2021-02-01T07:33:44.320Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>  出于线性代数Assignment的需要，学习了网页搜索领域很有名的PageRank算法，决定在这里记录下一些笔记</p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>PageRank简称PR，Google创始人拉里佩奇在提出此算法后创建了Google搜索引擎，其可以为网页打分以决定网页的排序，虽然搜索引擎对于网页的排序还由其他一些因素影响（<del>比如某度根据就给的💸有关</del>），但PageRank算法提供了一个很重要的判断标准。</p><blockquote><p>  也有人说PageRank算法是由创始人拉里佩奇（Larry Page）的名字命名的</p></blockquote><p>PageRank的核心原理基于一个重要的假设：一个重要的网站往往会被很多的网站所引用（指向）</p><p>基于这个假设，如果一个网站被很多网站指向，或者是被本身“权值”比较高的网站所指向，那么这个网站也是一个较为重要的网站</p><h2 id="一个小的例子"><a href="#一个小的例子" class="headerlink" title="一个小的例子"></a>一个小的例子</h2><p>核心的思想不太难，我们直接从一个小的例子说起。</p><p>现在有四个网站，A B C D，我们将四个网站抽象为图中的的四个节点（Node），并且将一个网站指向另一个网站的链接抽象为一条边（Edge），于是一个图诞生了</p><p>（直接用的作业里面画的图，字母和数字一一对应）</p><p><img src="https://www.hualigs.cn/image/6017add63584f.jpg" alt="figure0"></p><p>每个网站有一个最初的PageRank值，在最初的算法中，这个值是1，但为了满足概率介于1和0之间，所以我们将他们的值都设置为$\frac{1}{n}$，在这个例子中，这个值是0.25</p><p>对于一个网站的PR值，我们称为$PR()$</p><p>对于A节点，C节点和D节点指向了它，所以我们可以得到下面的式子：</p><p>$PR(A) = PR(C) + PR(D)$</p><p>但是，D不仅指向了A，还指向了C，所以，D给A投的票相当于$\frac{1}{2}PR(D)$，因此，刚才的式子应该是：</p><p>$PR(A) = PR(C) + \frac{PR(D)}{2}$</p><p>如果我们对于将页面向外指向的链接总数为$L()$</p><p>那么，对于点A，就有：</p><p>$PR(A) = \frac{PR(C)}{L(C)} + \frac{PR(D)}{L(D)}$</p><p>同理可得别的点的PR值，并且通过不断的递归，这个值将趋于稳定</p><p>同样可以采用矩阵的方式计算：</p><p>$A  = \begin{bmatrix}<br> 0 &amp; 0 &amp; 1 &amp; \frac{1}{2}\<br> \frac{1}{3} &amp; 0 &amp; 0 &amp; 0\<br> \frac{1}{3} &amp; \frac{1}{2} &amp; 0 &amp; \frac{1}{2}\<br> \frac{1}{3} &amp; \frac{1}{2} &amp; 0 &amp; 0<br>\end{bmatrix}$</p><p>第n列表示，节点N向外指向的点</p><p>比如，第1列，第2 3 4行 为 $\frac{1}{3}$，表示A指向3个节点，分别是节点BCD</p><p>$x  = \begin{bmatrix}<br> \frac{1}{4}\<br> \frac{1}{4}\<br> \frac{1}{4}\<br> \frac{1}{4}<br>\end{bmatrix}$</p><p>我们不断计算$x = Ax$</p><p>就可以得到一个稳定的$x$矩阵，这就是这四个网站的PageRank值</p><h2 id="一个问题"><a href="#一个问题" class="headerlink" title="一个问题"></a>一个问题</h2><p>为了方便理解，我们把“随机浏览者”的概念简化。</p><p>我们在日常生活上网时，不只是从一个网站点到另一个网站，还有可能是通过上方的地址栏直接输入url，跳转到对应的网址，所以我们在计算PageRank值时，引入一个阻尼系数d（damping factor），根据统计，这个直接输入网址的概率大概四0.85，其意义是：任意时刻，用户访问到某页面后继续访问下一个页面的概率，相对应的1-d则是用户停止点击，随机浏览新网页的概率</p><p>于是我们就得到了最终的求一个页面PageRank值的公式：</p><p>$\begin{equation}<br>PR_{t+1}(P_{i}) = \sum_{P_{j} }^{}PR_{t} \times \frac{P_{j} }{C(P_{j}) }<br>\end{equation}$</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>下面是我爬取学校网站，得到数据后，对其进行的排序的一个例子</p><p>We noticed that the links related to BJUT were not been indexed by Baidu or Google, So we apply the PageRank algorithm to BJUT’s web pages. We use <code>MATLAB R2020b</code> to implement this algorithm and all data is obtained using python crawler.</p><p>Create a directed graph with the sparse adjacency matrix <code>G</code>, using the urls contained in <code>name</code> as node names.</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">G = digraph(s,t,[],name)</span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">G = </span><br><span class="line">  digraph - with <span class="keyword">properties</span>:</span><br><span class="line"></span><br><span class="line">    Edges: [<span class="number">209</span>×<span class="number">1</span> <span class="built_in">table</span>]</span><br><span class="line">    Nodes: [<span class="number">55</span>×<span class="number">1</span> <span class="built_in">table</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>We set the damping factor 0.85, and use 200 iterations to compute the PageRank of sparse adjacency matrix G.  And add the scores and degree information into the nodes tables. </p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pr = centrality(G,<span class="string">&#x27;pagerank&#x27;</span>,<span class="string">&#x27;MaxIterations&#x27;</span>,<span class="number">200</span>,<span class="string">&#x27;FollowProbability&#x27;</span>,<span class="number">0.85</span>);</span><br><span class="line">G.Nodes.PageRank = pr;</span><br><span class="line">G.Nodes.InDegree = indegree(G);</span><br><span class="line">G.Nodes.OutDegree = outdegree(G);</span><br></pre></td></tr></table></figure><p>Print the top 25 scores.</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">G.Nodes(<span class="number">1</span>:<span class="number">25</span>,:)</span><br><span class="line"><span class="built_in">ans</span> = <span class="number">25</span>×<span class="number">4</span> <span class="built_in">table</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="left"></th><th align="center">Name</th><th align="center">PageRank</th><th align="center">InDegree</th><th align="center">OutDegree</th></tr></thead><tbody><tr><td align="left">1</td><td align="center">‘<a class="link"   href="http://www.bjut.edu.cn/&#39;" >http://www.bjut.edu.cn/&#39;<i class="fas fa-external-link-alt"></i></a></td><td align="center">0.0552</td><td align="center">20</td><td align="center">13</td></tr><tr><td align="left">2</td><td align="center">‘<a class="link"   href="http://news.bjut.edu.cn/&#39;" >http://news.bjut.edu.cn/&#39;<i class="fas fa-external-link-alt"></i></a></td><td align="center">0.0185</td><td align="center">7</td><td align="center">4</td></tr><tr><td align="left">3</td><td align="center">‘<a class="link"   href="https://app.bjut.edu.cn/&#39;" >https://app.bjut.edu.cn/&#39;<i class="fas fa-external-link-alt"></i></a></td><td align="center">0.0110</td><td align="center">2</td><td align="center">2</td></tr><tr><td align="left">4</td><td align="center">‘<a class="link"   href="http://60.bjut.edu.cn/&#39;" >http://60.bjut.edu.cn/&#39;<i class="fas fa-external-link-alt"></i></a></td><td align="center">0.0455</td><td align="center">3</td><td align="center">1</td></tr><tr><td align="left">5</td><td align="center">‘<a class="link"   href="http://portal2nd.bjut.edu.cn/&#39;" >http://portal2nd.bjut.edu.cn/&#39;<i class="fas fa-external-link-alt"></i></a></td><td align="center">0.0067</td><td align="center">4</td><td align="center">40</td></tr><tr><td align="left">6</td><td align="center">‘<a class="link"   href="http://eol2018.bjut.edu.cn/&#39;" >http://eol2018.bjut.edu.cn/&#39;<i class="fas fa-external-link-alt"></i></a></td><td align="center">0.0110</td><td align="center">2</td><td align="center">2</td></tr><tr><td align="left">7</td><td align="center">‘<a class="link"   href="http://lib.bjut.edu.cn/&#39;" >http://lib.bjut.edu.cn/&#39;<i class="fas fa-external-link-alt"></i></a></td><td align="center">0.0191</td><td align="center">6</td><td align="center">2</td></tr><tr><td align="left">8</td><td align="center">‘<a class="link"   href="http://iptv.bjut.edu.cn/&#39;" >http://iptv.bjut.edu.cn/&#39;<i class="fas fa-external-link-alt"></i></a></td><td align="center">0.0422</td><td align="center">2</td><td align="center">1</td></tr><tr><td align="left">9</td><td align="center">‘<a class="link"   href="http://gdjwgl.bjut.edu.cn/&#39;" >http://gdjwgl.bjut.edu.cn/&#39;<i class="fas fa-external-link-alt"></i></a></td><td align="center">0.0505</td><td align="center">3</td><td align="center">1</td></tr><tr><td align="left">10</td><td align="center">‘<a class="link"   href="http://xgxt.bjut.edu.cn/&#39;" >http://xgxt.bjut.edu.cn/&#39;<i class="fas fa-external-link-alt"></i></a></td><td align="center">0.0422</td><td align="center">2</td><td align="center">1</td></tr><tr><td align="left">11</td><td align="center">‘<a class="link"   href="https://cwc.bjut.edu.cn/&#39;" >https://cwc.bjut.edu.cn/&#39;<i class="fas fa-external-link-alt"></i></a></td><td align="center">0.0112</td><td align="center">3</td><td align="center">2</td></tr><tr><td align="left">12</td><td align="center">‘<a class="link"   href="http://bjutcie.bjut.edu.cn&/#39;" >http://bjutcie.bjut.edu.cn&#39;<i class="fas fa-external-link-alt"></i></a></td><td align="center">0.0089</td><td align="center">2</td><td align="center">3</td></tr><tr><td align="left">13</td><td align="center">‘<a class="link"   href="http://facte.bjut.edu.cn/&#39;" >http://facte.bjut.edu.cn/&#39;<i class="fas fa-external-link-alt"></i></a></td><td align="center">0.0081</td><td align="center">2</td><td align="center">4</td></tr><tr><td align="left">14</td><td align="center">‘<a class="link"   href="http://my.bjut.edu.cn/&#39;" >http://my.bjut.edu.cn/&#39;<i class="fas fa-external-link-alt"></i></a></td><td align="center">0.0929</td><td align="center">4</td><td align="center">1</td></tr></tbody></table><p>Extract and draw a subgraph that contains all nodes with a score greater than 0.005. Color the graph nodes according to their PageRank score.</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">H = subgraph(G,<span class="built_in">find</span>(G.Nodes.PageRank &gt; <span class="number">0.005</span>));</span><br><span class="line"><span class="built_in">plot</span>(H,<span class="string">&#x27;NodeLabel&#x27;</span>,&#123;&#125;,<span class="string">&#x27;NodeCData&#x27;</span>,H.Nodes.PageRank,<span class="string">&#x27;Layout&#x27;</span>,<span class="string">&#x27;force&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;Websites linked to https://www.bjut.edu.cn&#x27;</span>)</span><br><span class="line">colorbar</span><br></pre></td></tr></table></figure><p><img src="https://www.hualigs.cn/image/6017ae89f05bc.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;  出于线性代数Assignment的需要，学习了网页搜索领域很有名的PageRank算法，决定在这里记录下一些笔记&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    
    <category term="algorithm" scheme="https://dqhl76.com/tags/algorithm/"/>
    
  </entry>
  
</feed>
